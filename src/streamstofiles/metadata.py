"""Metadata file generation for playlist information."""

from datetime import datetime
from pathlib import Path
from typing import Any


class MetadataGenerator:
    """Generates metadata information files for playlists."""

    @staticmethod
    def generate_info_file(
        output_path: Path,
        playlist_url: str,
        playlist_info: dict[str, Any],
        concat_info: dict[str, Any] | None = None,
    ) -> Path:
        """
        Generate a metadata text file with playlist and track information.

        Args:
            output_path: Path where the info file should be saved
            playlist_url: Original YouTube playlist URL
            playlist_info: Dictionary containing:
                - playlist_title: Title of the playlist
                - playlist_dir: Directory where files are stored
                - total_tracks: Total number of tracks
                - files: List of file info dictionaries
            concat_info: Optional dictionary with concatenation info:
                - path: Path to concatenated file
                - timestamps: List of timestamp dictionaries
                - total_duration: Total duration in seconds

        Returns:
            Path to the created info file
        """
        lines = []

        # Header
        lines.append("=" * 80)
        lines.append("PLAYLIST METADATA")
        lines.append("=" * 80)
        lines.append("")

        # Playlist information
        lines.append(f"Playlist Title: {playlist_info['playlist_title']}")
        lines.append(f"Playlist URL: {playlist_url}")
        lines.append(f"Total Tracks: {playlist_info['total_tracks']}")
        lines.append(f"Download Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(f"Output Directory: {playlist_info['playlist_dir']}")
        lines.append("")

        # Concatenated file information (if available)
        if concat_info:
            lines.append("=" * 80)
            lines.append("CONCATENATED FILE")
            lines.append("=" * 80)
            lines.append("")
            lines.append(f"Concatenated File: {concat_info['path'].name}")
            lines.append(f"Total Duration: {MetadataGenerator._format_duration(concat_info['total_duration'])}")
            lines.append("")
            lines.append("Track Timestamps (for navigation in concatenated file):")
            lines.append("")

            for ts in concat_info["timestamps"]:
                lines.append(f"  Track {ts['track_number']}: {ts['title']}")
                lines.append(f"    Start: {ts['start_formatted']} | End: {ts['end_formatted']}")
                lines.append(f"    Duration: {MetadataGenerator._format_duration(ts['duration'])}")
                lines.append("")

            lines.append("")

        # Track listing
        lines.append("=" * 80)
        lines.append("TRACK LISTING")
        lines.append("=" * 80)
        lines.append("")

        for idx, file_info in enumerate(playlist_info["files"], start=1):
            lines.append(f"Track {idx}/{playlist_info['total_tracks']}:")
            lines.append(f"  Title: {file_info['title']}")
            lines.append(f"  Artist: {file_info['artist']}")
            lines.append(f"  Duration: {MetadataGenerator._format_duration(file_info['duration'])}")
            lines.append(f"  YouTube URL: {file_info['url']}")
            lines.append(f"  File: {file_info['path'].name}")
            lines.append("")

        # Footer
        lines.append("=" * 80)
        lines.append("Generated by StreamsToFiles - YouTube Playlist to MP3 Converter")
        lines.append("https://github.com/yourusername/tools-streamstofiles")
        lines.append("=" * 80)

        # Write to file
        output_path.write_text("\n".join(lines), encoding="utf-8")

        return output_path

    @staticmethod
    def _format_duration(seconds: int) -> str:
        """
        Format duration in seconds to HH:MM:SS or MM:SS.

        Args:
            seconds: Duration in seconds

        Returns:
            Formatted duration string
        """
        if seconds <= 0:
            return "Unknown"

        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        secs = seconds % 60

        if hours > 0:
            return f"{hours:02d}:{minutes:02d}:{secs:02d}"
        else:
            return f"{minutes:02d}:{secs:02d}"
